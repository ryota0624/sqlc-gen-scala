// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package com.example.booktest.postgresql

import java.sql.Connection
import java.sql.SQLException
import java.sql.Statement
import java.sql.Types
import java.time.OffsetDateTime
import scala.util.Using

val booksByTagsSQL = """-- name: booksByTags :many
SELECT 
  book_id,
  title,
  name,
  isbn,
  tags
FROM books
LEFT JOIN authors ON books.author_id = authors.author_id
WHERE tags && ?::varchar[]
"""

case class BooksByTagsRow (
  bookId: Int,
  title: String,
  name: Option[String],
  isbn: String,
  tags: Array[String]
)

val booksByTitleYearSQL = """-- name: booksByTitleYear :many
SELECT book_id, author_id, isbn, book_type, title, year, available, tags FROM books
WHERE title = ? AND year = ?
"""

val createAuthorSQL = """-- name: createAuthor :one
INSERT INTO authors (name) VALUES (?)
RETURNING author_id, name
"""

val createBookSQL = """-- name: createBook :one
INSERT INTO books (
    author_id,
    isbn,
    book_type,
    title,
    year,
    available,
    tags
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
RETURNING book_id, author_id, isbn, book_type, title, year, available, tags
"""

val deleteBookSQL = """-- name: deleteBook :exec
DELETE FROM books
WHERE book_id = ?
"""

val getAuthorSQL = """-- name: getAuthor :one
SELECT author_id, name FROM authors
WHERE author_id = ?
"""

val getBookSQL = """-- name: getBook :one
SELECT book_id, author_id, isbn, book_type, title, year, available, tags FROM books
WHERE book_id = ?
"""

val updateBookSQL = """-- name: updateBook :exec
UPDATE books
SET title = ?, tags = ?
WHERE book_id = ?
"""

val updateBookISBNSQL = """-- name: updateBookISBN :exec
UPDATE books
SET title = ?, tags = ?, isbn = ?
WHERE book_id = ?
"""

class QueriesImpl(private val conn: Connection) extends Queries {

  override def booksByTags(dollar1: Array[String]): List[BooksByTagsRow] = {
    Using.resource(conn.prepareStatement(booksByTagsSQL)) { stmt =>
      stmt.setArray(1, conn.createArrayOf("pg_catalog.varchar", dollar1.toArray()))

      val results = stmt.executeQuery()
      val ret = scala.collection.mutable.ListBuffer.empty[BooksByTagsRow]
      while (results.next()) {
          ret += BooksByTagsRow(
                results.getInt(1),
                results.getString(2),
                Option(results.getObject(3)).map { _ => results.getString(3) },
                results.getString(4),
                results.getArray(5).getArray().asInstanceOf[Array[String]]
            )
      }
      ret.toList
    }
  }

  override def booksByTitleYear(title: String, year: Int): List[Book] = {
    Using.resource(conn.prepareStatement(booksByTitleYearSQL)) { stmt =>
      stmt.setString(1, title)
          stmt.setInt(2, year)

      val results = stmt.executeQuery()
      val ret = scala.collection.mutable.ListBuffer.empty[Book]
      while (results.next()) {
          ret += Book(
                results.getInt(1),
                results.getInt(2),
                results.getString(3),
                BookType.valueOf(results.getString(4)),
                results.getString(5),
                results.getInt(6),
                results.getObject(7, classOf[OffsetDateTime]),
                results.getArray(8).getArray().asInstanceOf[Array[String]]
            )
      }
      ret.toList
    }
  }

  override def createAuthor(name: String): Option[Author] = {
    Using.resource(conn.prepareStatement(createAuthorSQL)) { stmt =>
      stmt.setString(1, name)

      val results = stmt.executeQuery()
      Option.when(results.next()) {
        val ret = Author(
                results.getInt(1),
                results.getString(2)
            )
        if (results.next()) {
          throw SQLException("expected one row in result set, but got many")
        }
        ret
      }
    }
  }

  override def createBook(
      authorId: Int,
      isbn: String,
      bookType: BookType,
      title: String,
      year: Int,
      available: OffsetDateTime,
      tags: Array[String]): Option[Book] = {
    Using.resource(conn.prepareStatement(createBookSQL)) { stmt =>
      stmt.setInt(1, authorId)
          stmt.setString(2, isbn)
          stmt.setObject(3, bookType.value, Types.OTHER)
          stmt.setString(4, title)
          stmt.setInt(5, year)
          stmt.setObject(6, available)
          stmt.setArray(7, conn.createArrayOf("pg_catalog.varchar", tags.toArray()))

      val results = stmt.executeQuery()
      Option.when(results.next()) {
        val ret = Book(
                results.getInt(1),
                results.getInt(2),
                results.getString(3),
                BookType.valueOf(results.getString(4)),
                results.getString(5),
                results.getInt(6),
                results.getObject(7, classOf[OffsetDateTime]),
                results.getArray(8).getArray().asInstanceOf[Array[String]]
            )
        if (results.next()) {
          throw SQLException("expected one row in result set, but got many")
        }
        ret
      }
    }
  }

  override def deleteBook(bookId: Int): Unit = {
    Using.resource(conn.prepareStatement(deleteBookSQL)) { stmt =>
      stmt.setInt(1, bookId)

      stmt.execute()
    }
  }

  override def getAuthor(authorId: Int): Option[Author] = {
    Using.resource(conn.prepareStatement(getAuthorSQL)) { stmt =>
      stmt.setInt(1, authorId)

      val results = stmt.executeQuery()
      Option.when(results.next()) {
        val ret = Author(
                results.getInt(1),
                results.getString(2)
            )
        if (results.next()) {
          throw SQLException("expected one row in result set, but got many")
        }
        ret
      }
    }
  }

  override def getBook(bookId: Int): Option[Book] = {
    Using.resource(conn.prepareStatement(getBookSQL)) { stmt =>
      stmt.setInt(1, bookId)

      val results = stmt.executeQuery()
      Option.when(results.next()) {
        val ret = Book(
                results.getInt(1),
                results.getInt(2),
                results.getString(3),
                BookType.valueOf(results.getString(4)),
                results.getString(5),
                results.getInt(6),
                results.getObject(7, classOf[OffsetDateTime]),
                results.getArray(8).getArray().asInstanceOf[Array[String]]
            )
        if (results.next()) {
          throw SQLException("expected one row in result set, but got many")
        }
        ret
      }
    }
  }

  override def updateBook(
      title: String,
      tags: Array[String],
      bookId: Int): Unit = {
    Using.resource(conn.prepareStatement(updateBookSQL)) { stmt =>
      stmt.setString(1, title)
          stmt.setArray(2, conn.createArrayOf("pg_catalog.varchar", tags.toArray()))
          stmt.setInt(3, bookId)

      stmt.execute()
    }
  }

  override def updateBookISBN(
      title: String,
      tags: Array[String],
      isbn: String,
      bookId: Int): Unit = {
    Using.resource(conn.prepareStatement(updateBookISBNSQL)) { stmt =>
      stmt.setString(1, title)
          stmt.setArray(2, conn.createArrayOf("pg_catalog.varchar", tags.toArray()))
          stmt.setString(3, isbn)
          stmt.setInt(4, bookId)

      stmt.execute()
    }
  }

}

